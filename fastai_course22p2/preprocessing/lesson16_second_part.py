"""Reproducing lesson 16 part2"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/04_preprocessing.lesson_16_second_part.ipynb.

# %% auto 0
__all__ = ['dsd', 'set_seed', 'transformi', 'prep_data', 'conv', 'conv_layers', 'fit', 'SequentialModel', 'append_stats', 'Hook',
           'Hooks', 'get_hist', 'show_image', 'get_min', 'Callback', 'HooksCallback', 'subplots', 'get_grid',
           'ActivationStats']

# %% ../../nbs/04_preprocessing.lesson_16_second_part.ipynb 3
from cv_tools.core import *


# %% ../../nbs/04_preprocessing.lesson_16_second_part.ipynb 4
import matplotlib as mpl
import logging
import random
import numpy as np
import matplotlib.pyplot as plt
from functools import partial
from fastcore.all import *
logging.disable(logging.WARNING)

# %% ../../nbs/04_preprocessing.lesson_16_second_part.ipynb 5
from datasets import load_dataset

# %% ../../nbs/04_preprocessing.lesson_16_second_part.ipynb 6
import torch
import torch.nn as nn
import torch.nn.functional as F
import torchvision.transforms.functional as TF
from torcheval.metrics import MulticlassAccuracy

# %% ../../nbs/04_preprocessing.lesson_16_second_part.ipynb 7
from fastai_course22p2.preprocessing.lesson16_after_lesson import *

# %% ../../nbs/04_preprocessing.lesson_16_second_part.ipynb 8
def set_seed(seed, deterministic=False):
    torch.use_deterministic_algorithms(deterministic)
    torch.manual_seed(seed)
    random.seed(seed)
    np.random.seed(seed)

# %% ../../nbs/04_preprocessing.lesson_16_second_part.ipynb 10
@inplace
def transformi(b):
	b['image'] = [TF.to_tensor(o) for o in b['image']]


# %% ../../nbs/04_preprocessing.lesson_16_second_part.ipynb 12
dsd = load_dataset('fashion_mnist')
def prep_data():
	tds = dsd.with_transform(transformi)
	dls = DataLoaders.from_dd(tds, batch_size=1024, num_workers=4)
	return dls


# %% ../../nbs/04_preprocessing.lesson_16_second_part.ipynb 14
def conv(ni, nf, ks=3, act=True):
	res = nn.Conv2d(ni, nf, ks, stride=2, padding=ks//2)
	if act: res = nn.Sequential(res, nn.ReLU())
	return res


# %% ../../nbs/04_preprocessing.lesson_16_second_part.ipynb 15
def conv_layers():
	return [
		conv(1, 8, ks=5), # 14x14
		conv(8, 16), # 7x7
		conv(16, 32), # 4x4
		conv(32, 64), # 2x2
		conv(64, 10, act=False), # 1x1
		nn.Flatten()
	]

# %% ../../nbs/04_preprocessing.lesson_16_second_part.ipynb 17
def fit(model, epochs=1):
	learn = Learner(
		model, dls, 
		loss_func=F.cross_entropy, 
		lr=0.6,
		cbs=cbs,
	)
	learn.fit(epochs)
	return learn


# %% ../../nbs/04_preprocessing.lesson_16_second_part.ipynb 21
class SequentialModel(nn.Module):
	def __init__(self, *layers):
		super().__init__()
		self.layers = nn.ModuleList(layers)
		self.act_means = [[] for _ in self.layers]
		self.act_stds = [[] for _ in self.layers]

	def __call__(self, x):
		for i, layer in enumerate(self.layers):
			x = layer(x)
			self.act_means[i].append(to_cpu(x.mean()))
			self.act_stds[i].append(to_cpu(x.std()))
		return x

	def __iter__(self):
		return iter(self.layers)

	def __len__(self):
		return len(self.layers)


# %% ../../nbs/04_preprocessing.lesson_16_second_part.ipynb 27
def append_stats(i, mod, inp, out):
	act_means[i].append(to_cpu(out.mean()))
	act_stds[i].append(to_cpu(out.std()))


# %% ../../nbs/04_preprocessing.lesson_16_second_part.ipynb 31
class Hook():
	def __init__(self, module, func):
		self.hook = module.register_forward_hook(partial(func, self))

	def remove(self):
		self.hook.remove()

	def __del__(self):
		self.remove()


# %% ../../nbs/04_preprocessing.lesson_16_second_part.ipynb 32
def append_stats(h, mod, inp, out):
	if not hasattr(h, 'stats'):h.stats = ([], [])
	act = to_cpu(out)
	h.stats[0].append(act.mean())
	h.stats[1].append(act.std())


# %% ../../nbs/04_preprocessing.lesson_16_second_part.ipynb 37
class Hooks(list):
	# Initialize the Hooks class by creating a list of Hook objects for each module in the input list 'ms'.
	# Each Hook is created with the module 'm' and the function 'append_stats'.
	def __init__(self, ms, f):
		super().__init__([Hook(m, f) for m in ms])
	
	# This method is called when the Hooks object is used as a context manager.
	# It returns the Hooks object itself, allowing it to be used in a 'with' statement.
	def __enter__(self, *args):return self
	# This method is called when the 'with' statement is exited.
	# It calls the 'remove' method to clean up any resources used by the Hooks.
	def __exit__(self, *args):self.remove()
	# This method is called when the Hooks object is about to be garbage collected.
	# It calls the 'remove' method to clean up any resources used by the Hooks.
	def __del__(self):self.remove()
	# This method is called when an item is deleted from the Hooks list.
	# It removes the Hook object at the specified index 'i' and then calls the superclass's __delitem__ method.
	def __delitem__(self, i):
		self[i].remove()
		super().__delitem__(i)
	# This method removes all Hook objects in the Hooks list.
	# It iterates over each Hook in the list and calls its 'remove' method.
	def remove(self):
		for h in self: h.remove()

# %% ../../nbs/04_preprocessing.lesson_16_second_part.ipynb 41
def append_stats(h, mod, inp, out):
	if not hasattr(h, 'stats'):h.stats = ([], [], [])
	act = to_cpu(out)
	h.stats[0].append(act.mean())
	h.stats[1].append(act.std())
	h.stats[2].append(act.histc(40,0, 10))



# %% ../../nbs/04_preprocessing.lesson_16_second_part.ipynb 46
def get_hist(h):return torch.stack(h.stats[2]).t().float().log1p()



# %% ../../nbs/04_preprocessing.lesson_16_second_part.ipynb 47
delegates(plt.Axes.imshow)
def show_image(im, ax=None, figsize=None, title=None, noframe=True, **kwargs):
    "Show a PIL or PyTorch image on `ax`."
    if hasattrs(im, ('cpu','permute','detach')):
        im = im.detach().cpu()
        if len(im.shape)==3 and im.shape[0]<5: im=im.permute(1,2,0)
    elif not isinstance(im,np.ndarray): im=np.array(im)
    if im.shape[-1]==1: im=im[...,0]
    if ax is None: _,ax = plt.subplots(figsize=figsize)
    ax.imshow(im, **kwargs)
    if title is not None: ax.set_title(title)
    ax.set_xticks([]) 
    ax.set_yticks([]) 
    if noframe: ax.axis('off')
    return ax

# %% ../../nbs/04_preprocessing.lesson_16_second_part.ipynb 52
def get_min(h):
	h1 = torch.stack(h.stats[2]).t().float().log1p()
	return h1[:2].sum(0)/h1.sum(0)



# %% ../../nbs/04_preprocessing.lesson_16_second_part.ipynb 55
class Callback:
	order = 0
	_fwd = 'model', 'opt','batch', 'epoch'

	def __getattr__(self, name):
		if name in self._fwd: 
			return getattr(self.learn,name)
		raise AttributeError(name)

	def __setattr__(self, name, value):
		if name in self._fwd: warn(f'Setting {name} in a callback,Did you mean to set learn.{name}`?')
		super().__setattr__(name, value)

	@property
	def training(self): return self.model.training


# %% ../../nbs/04_preprocessing.lesson_16_second_part.ipynb 56
class HooksCallback(Callback):
	def __init__(
			self, 
			hookfunc, 
			mod_filter=noop, 
			on_train=True, 
			on_valid=True,
			mods=None):
		store_attr()
		super().__init__()

	def before_fit(self,learn):
		if self.mods: mods = self.mods
		else: mods = filter_ex(
			learn.model.modules(), self.mod_filter)
		self.hooks = Hooks(mods, partial(self._hookfunc, learn))

	def _hookfunc(self, learn,*args, **kwargs):
		if (self.on_train and learn.training) or (self.on_valid and not learn.training): 
			self.hookfunc(*args, **kwargs)

	def after_fit(self, learn):
		self.hooks.remove()

	def __iter__(self):
		return iter(self.hooks)

	def __len__(self):
		return len(self.hooks)


# %% ../../nbs/04_preprocessing.lesson_16_second_part.ipynb 58
def fit(model, epochs=1, xtra_cbs=None):
    learn = Learner(
        model, 
        dls, 
        loss_func=F.cross_entropy, 
        lr=0.6, cbs=cbs+L(xtra_cbs))
    learn.fit(epochs)
    return learn

# %% ../../nbs/04_preprocessing.lesson_16_second_part.ipynb 62
@delegates(plt.subplots, keep=True)
def subplots(
    nrows:int=1, # Number of rows in returned axes grid
    ncols:int=1, # Number of columns in returned axes grid
    figsize:tuple=None, # Width, height in inches of the returned figure
    imsize:int=3, # Size (in inches) of images that will be displayed in the returned figure
    suptitle:str=None, # Title to be set to returned figure
    **kwargs
): # fig and axs
    "A figure and set of subplots to display images of `imsize` inches"
    if figsize is None: figsize=(ncols*imsize, nrows*imsize)
    fig,ax = plt.subplots(nrows, ncols, figsize=figsize, **kwargs)
    if suptitle is not None: fig.suptitle(suptitle)
    if nrows*ncols==1: ax = np.array([ax])
    return fig,ax


# %% ../../nbs/04_preprocessing.lesson_16_second_part.ipynb 63
@delegates(subplots)
def get_grid(
    n:int, # Number of axes
    nrows:int=None, # Number of rows, defaulting to `int(math.sqrt(n))`
    ncols:int=None, # Number of columns, defaulting to `ceil(n/rows)`
    title:str=None, # If passed, title set to the figure
    weight:str='bold', # Title font weight
    size:int=14, # Title font size
    **kwargs,
): # fig and axs
    "Return a grid of `n` axes, `rows` by `cols`"
    if nrows: ncols = ncols or int(np.floor(n/nrows))
    elif ncols: nrows = nrows or int(np.ceil(n/ncols))
    else:
        nrows = int(math.sqrt(n))
        ncols = int(np.floor(n/nrows))
    fig,axs = subplots(nrows, ncols, **kwargs)
    for i in range(n, nrows*ncols): axs.flat[i].set_axis_off()
    if title is not None: fig.suptitle(title, weight=weight, size=size)
    return fig,axs

# %% ../../nbs/04_preprocessing.lesson_16_second_part.ipynb 64
class ActivationStats(HooksCallback):
    def __init__(self, mod_filter=noop): super().__init__(append_stats, mod_filter)

    def color_dim(self, figsize=(11,5)):
        fig,axes = get_grid(len(self), figsize=figsize)
        for ax,h in zip(axes.flat, self):
            show_image(get_hist(h), ax, origin='lower')

    def dead_chart(self, figsize=(11,5)):
        fig,axes = get_grid(len(self), figsize=figsize)
        for ax,h in zip(axes.flatten(), self):
            ax.plot(get_min(h))
            ax.set_ylim(0,1)

    def plot_stats(self, figsize=(10,4)):
        fig,axs = plt.subplots(1,2, figsize=figsize)
        for h in self:
            for i in 0,1: axs[i].plot(h.stats[i])
        axs[0].set_title('Means')
        axs[1].set_title('Stdevs')
        plt.legend(L.range(self))
